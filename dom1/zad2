func evaluate(expression : String) -> Int
{
  var str:String = expression
  var numbers:[Int] = []
  var operations:String = ""
  var num:Int = 0
  var b = false
  for i in 0..<str.characters.count
  { 
   var ch = str[str.index(str.startIndex, offsetBy: i)]
   if isOperator(str:ch)
    {
     if b 
     {numbers.append(num)}
     num = 0;
     b = false
     while (operations.isEmpty ||
           priority(operations[operations.endIndex]) <= priority(ch))
           
          {
              var a = numbers.remove(at:numbers.count - 1)
              /*var b = numbers.remove(at:numbers.count - 1)
             var op = operations.remove(at: operations.index(before: operations.endIndex))
              var result = execute(a:a,b:b,op:op)
              numbers.append(result)*/
          } 
     operations.insert(ch, at: operations.endIndex)      
    }
    else
    {
     if Int(String(ch)) != nil
       {
         num = num*10 + Int(String(ch))! 
         b = true
       }
    }
    //print(operations)
    //print(numbers)
  }
  if b
  {numbers.append(num)}
  return 5
}
func isOperator(str:Character) -> Bool
{
    return str == "*" || str == "/" || str=="-" || str == "+"
                      || str == "^" || str=="(" || str == ")"
}
func priority(_ str:Character) -> Int 
{
 if str == "^"               {return 2}
 if str == "*" || str == "/" {return 1}
 if str == "+" || str == "-" {return 0}
 return -1
}
func execute(a:Int,b:Int,op:Character) -> Int
{
    switch op
    {
    case "+" : return a + b
    case "-" : return a - b
    case "*" : return a * b
    case "/" : return a / b
    default  : return 0
    }
}

evaluate(expression :"1 5 0") 
