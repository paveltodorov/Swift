struct Attribute
{
    var name:String
    var type:String
    init(name:String = "",type:String = "")
    {
        self.name = name
        self.type = type
    }
}
struct Function
{
    var name:String
    var body:String
    var type:String
    var parameters:[Attribute]=[]
    init(name:String = "",type:String = "",body:String="",parameters:[Attribute] = [])
    {
        self.name = name
        self.body = body
        self.type = type
        self.parameters = parameters
    }
}

struct ClassAndExpansion
{   
    var isClass:Bool = true
    var name:String = ""
    var inherits:[String] = []
    var funcArr:[Function] = []
    var attributes:[Attribute] = []
    init(name:String="",isClass:Bool = true,
         inherits:[String] = [],attributes:[Attribute] = [],funcArr:[Function] = [])
    {
      self.isClass = isClass 
      self.name = name
      self.inherits = inherits
      self.funcArr = funcArr
      self.attributes = attributes
    }
}
func isFunction(str:String)->Bool
{
	var j:Int = 0
	var ch:Character
	while (j < str.characters.count)
	{
     ch = str[str.index(str.startIndex, offsetBy: j)]
	 if ch == "("
	 {return true}
	j += 1
	}
	return false
}
func contains(_ arr:[Character],_ ch:Character)->Bool
{
    for i:Character in arr
    {
        if i == ch
        {
            return true
        }
    }
    return false
}
func skipSymbol(file:String,i:inout Int,till:[Character])->(str:String,ch:Character)
{
    var str:String = ""
    var ch:Character = " "
    repeat
                   {
                       ch = file[file.index(file.startIndex, offsetBy: i)]
                       str.insert(ch, at: str.endIndex)
                       i += 1
                   }
    while (i < file.characters.count && !contains(till,ch))
    if i == file.characters.count
    {
		i = -50
		//return (str,"1") 
	}
    ch=str.remove(at: str.index(before: str.endIndex))
    return (str,ch) 
}
func skipWhite(file:String,i:inout Int) -> Void
{
	var ch:Character
	repeat
                   {
                       ch = file[file.index(file.startIndex, offsetBy: i)]
                       i += 1
                   }
    while (i < file.characters.count && ch == " ")
	i -= 1
}
func parse(file:String)->[ClassAndExpansion]
{
    var data:[ClassAndExpansion] = []
    var i = 0
	var tuple:(str:String,ch:Character) 
	while(i >= 0)
	{
	  var c:ClassAndExpansion = ClassAndExpansion()	
	  tuple = skipSymbol(file:file,i:&i,till:["$","+"])
		if i < 0
		{
			break
		}
	  if tuple.ch == "$"
		{
		c.isClass = true	
		}
      else
		{
		c.isClass = false	
		}
	  skipWhite(file:file,i:&i)
	  var tuple2:(str:String,ch:Character) = skipSymbol(file:file,i:&i,till:[" ",":"])
	  c.name = tuple2.str
	 
	  
	  data.append(c)	
	}   
  return data
}
//print()
var i = 0
//print(skipSymbol(file:"    go to",i:&i,till:["j"]))
//print(i)
var file:String = "+ prot1 +prot2 $class1"
print(parse(file:file))
